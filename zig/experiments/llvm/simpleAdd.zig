const std = @import("std");
const llvm = @import("llvm-build-module");
const target = llvm.target;
const types = llvm.types;
const core = llvm.core;
const analysis = llvm.analysis;
const orc = llvm.orc;
const lljit = llvm.jit;
const engine = llvm.engine;
const target_machine = llvm.target_machine;

// Build: `zig build -DExamples=true`
// Run: `./zig-out/bin/example`

pub fn main() !void {

    // LLVM target specific setup logic
    target.initNativeTarget();

    // Create downward growing stack - smaller indices for more pushes
    var stack: [5]i64 = .{ 0, 0, 0, 4, 5 };
    std.debug.print("Stack before: {any}\n", .{stack});
    _ = &stack[3]; // top is at index 3 = value 4

    // Create LLVM module (context created by default)
    const module: types.LLVMModuleRef = core.LLVMModuleCreateWithName("module");
    const builder: types.LLVMBuilderRef = core.LLVMCreateBuilder();

    // Fill module with IR
    _ = try populateModule(module, builder);

    // Create the LLJIT Builder
    const jitBuilder = lljit.LLVMOrcCreateLLJITBuilder();

    // Create the LLJIT Instance
    var jit: types.LLVMOrcLLJITRef = undefined;
    if (lljit.LLVMOrcCreateLLJIT(&jit, jitBuilder) != null) {
        return error.LLJITCreationFailure;
    }

    // Add IR module to JIT instance
    const dylib = lljit.LLVMOrcLLJITGetMainJITDylib(jit);
    if (dylib == null) {
        return error.JITDylibRetrievalFailure;
    }
    const threadRef = orc.LLVMOrcCreateNewThreadSafeContext();
    const threadSafeModule = orc.LLVMOrcCreateNewThreadSafeModule(module, threadRef);

    if (lljit.LLVMOrcLLJITAddLLVMIRModule(jit, dylib, threadSafeModule) != null) {
        return error.AddModuleToJITFailure;
    }

    // Look up synbol to execute
    var result: orc.LLVMOrcExecutorAddress = 0;
    if (lljit.LLVMOrcLLJITLookup(jit, &result, "stack_add_top_two") != null) {
        return error.SymbolLookupFailure;
    }

    const stackAddTopTwoFn: *const fn (*i64) callconv(.C) *i64 = @ptrFromInt(result);
    const newSp = stackAddTopTwoFn(&stack[3]);
    const valueAtNewSp: *const i64 = @ptrCast(newSp);
    std.debug.print("Value at stack pointer: {}\n", .{valueAtNewSp.*});
}

pub fn populateModule(module: types.LLVMModuleRef, builder: types.LLVMBuilderRef) !types.LLVMModuleRef {
    const i64Type: types.LLVMTypeRef = core.LLVMInt64Type();
    const i64PtrType: types.LLVMTypeRef = core.LLVMPointerType(i64Type, 0);

    // Create the addition_func function
    var paramTypes: [1]types.LLVMTypeRef = .{i64PtrType};
    const funcType: types.LLVMTypeRef = core.LLVMFunctionType(i64PtrType, &paramTypes[0], 1, 0);
    const fnAddTopTwo: types.LLVMValueRef = core.LLVMAddFunction(module, "stack_add_top_two", funcType);

    // Set param name
    const spParam: types.LLVMValueRef = core.LLVMGetParam(fnAddTopTwo, 0);
    core.LLVMSetValueName(spParam, "sp");

    // Setup the function body
    const entryBlock: types.LLVMBasicBlockRef = core.LLVMAppendBasicBlock(fnAddTopTwo, "entry");
    core.LLVMPositionBuilderAtEnd(builder, entryBlock);

    // Load top stack element, update sp
    const val1 = core.LLVMBuildLoad2(builder, i64Type, spParam, "val1");
    const sp_1 = buildGEP(builder, i64Type, spParam, 1, "sp_1");

    // Load the next element, update sp
    const val2 = core.LLVMBuildLoad2(builder, i64Type, sp_1, "val2");
    const sp_2 = buildGEP(builder, i64Type, sp_1, 1, "sp_2");

    // Perform Add
    const sumVal = core.LLVMBuildAdd(builder, val1, val2, "sumVal");

    // Push sumVal on the stack
    const sp_3 = buildGEP(builder, i64Type, sp_2, -1, "sp_3");
    _ = core.LLVMBuildStore(builder, sumVal, sp_3);

    _ = core.LLVMBuildRet(builder, sp_3);

    // Verify the module and capture the message
    var errorMessage: [*c]u8 = undefined;
    const cErrorMessagePtr: [*c][*c]u8 = @ptrCast(&errorMessage);
    if (analysis.LLVMVerifyModule(module, types.LLVMVerifierFailureAction.LLVMPrintMessageAction, cErrorMessagePtr) != 0) {
        if (errorMessage) |msg| {
            defer core.LLVMDisposeMessage(msg); // ensures cleanup
            std.debug.print("Verification failed: {s}\n", .{msg});
            return error.ModuleVerificationFailure;
        } else {
            return error.UnknownCauseModuleVerificationFailure;
        }
    } else {
        std.debug.print("Module verification passed.\n", .{});
    }

    std.debug.print("\n--- IR DUMP ---\n", .{});
    core.LLVMDumpModule(module);
    std.debug.print("--- END IR ---\n\n", .{});

    // Cleanup builder
    core.LLVMDisposeBuilder(builder);
    return module;
}

inline fn buildGEP(builder: types.LLVMBuilderRef, elementType: types.LLVMTypeRef, base: types.LLVMValueRef, offset: i64, name: []const u8) types.LLVMValueRef {
    const offset_bits: u64 = @bitCast(offset);
    const signExtend = offset < 0;
    const idx = [_]types.LLVMValueRef{core.LLVMConstInt(elementType, offset_bits, @intFromBool(signExtend))};
    const idx_ptr: [*c]types.LLVMValueRef = @constCast(@ptrCast(&idx[0]));
    return core.LLVMBuildGEP2(builder, elementType, base, idx_ptr, 1, @ptrCast(name));
}
